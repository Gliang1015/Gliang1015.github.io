<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>爬虫-01</title>
      <link href="/2024/07/05/crawler01/"/>
      <url>/2024/07/05/crawler01/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫01"><a href="#爬虫01" class="headerlink" title="爬虫01"></a>爬虫01</h1><p>在经过了解和学前准备之后，就要开启真正的爬虫之旅了。</p><h2 id="http协议以及请求头的介绍"><a href="#http协议以及请求头的介绍" class="headerlink" title="http协议以及请求头的介绍"></a>http协议以及请求头的介绍</h2><h3 id="网络请求的发送和响应接收"><a href="#网络请求的发送和响应接收" class="headerlink" title="网络请求的发送和响应接收"></a>网络请求的发送和响应接收</h3><p><img src="/img/crawler01/01.png"></p><ul><li>电脑通过浏览器将域名发送给DNS服务器。</li><li>DNS服务器将域名解析成IP地址返还给电脑。（每一个IP地址指定特定的一台电脑或者服务器）</li><li>电脑通过IP地址访问目的服务器所在的地址。</li><li>目的服务武器返回数据给电脑。</li></ul><h3 id="http与https协议"><a href="#http与https协议" class="headerlink" title="http与https协议"></a>http与https协议</h3><p><img src="/img/crawler01/02.png"><br>当我们向服务器请求数据的时候，需要遵循http协议，https协议，这是一种默认的规则。<br>当我们向服务器请求数据的时候，需要某些信息的记录，才能拿到数据。<br>https相较于http多了一层加密，优点是更加安全，缺点是效率受影响。</p><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><p>当我们访问网站时，网站返回我们数据包，其主要内容如下：</p><ul><li>Headers：请求信息request、响应信息response。</li><li>Preview：预览效果。</li><li>Response：数据包的类型时html，里面放的是这个html的源代码。</li></ul><p>其中对我们比较重要的是Headers，其内容有：</p><ul><li>General：整体的信息描述。<ul><li>Request URL：该数据包对应的域名。</li><li>Request Method：请求方式 GET POST。</li><li>Status Code：状态码，用来描述请求结果的。</li><li>Remote ADDress：ip:端口号。</li></ul></li><li>Response Headers（响应头）：响应信息服务需要遵循这种股则协议，浏览器才能解析，并且展示。</li><li>Request Headers：<ul><li>Accept：我们接受哪些数据类型。</li><li>Accept-Encoding：浏览器接受的编码类型。</li><li>Accept-Language：接受语言。</li><li>Connection：长连接。</li><li>Cookie：记录会话信息，包含用户名和服务器的交流信息，身份信息，具体表现有下次访问不用填写账号密码。</li><li>Host：主机地址 域名 url。</li><li>User-Agent：记录客户端的信息，用户代理。</li></ul></li></ul><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>我们使用python向服务器发送请求，需要将python数据类型转换成字节类型（编码），才能在网络上传输，而服务器返回的数据的数据类型是字节类型，要使我们能看懂，需要转换成python数据类型（解码）。</p><ul><li>encode：python数据类型  &gt;&gt; bytes类型</li><li>decode：bytes类型 &gt;&gt; python数据类型<br>注：编码格式要和解码格式保持一致，其中默认值都为’utf-8’。</li></ul><h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><h3 id="requests库的下载"><a href="#requests库的下载" class="headerlink" title="requests库的下载"></a>requests库的下载</h3><p>我么可以通过这个库进行浏览器的模拟去访问服务器，但是是第三方模块，所以需要我们进行下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workon pachong</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure><h3 id="requests库的使用"><a href="#requests库的使用" class="headerlink" title="requests库的使用"></a>requests库的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入发送网络请求的requests库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># requests库封装了urllib3库，使得我们使用起来更加方便</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 确认目标url</span></span><br><span class="line">    url_ = <span class="string">&#x27;https://www.baidu.com/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送网络请求，获取响应</span></span><br><span class="line">    response_ = requests.get(url_) <span class="comment"># 目标url,利用requests库发送的网络请求，最终得到一个响应对象response</span></span><br><span class="line">    <span class="built_in">print</span>(response_)</span><br><span class="line">    <span class="built_in">print</span>(response_.encoding) <span class="comment"># 打印响应的编码格式，就是text属性自动检测到的编解码格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(response_.text)  #打印响应的文本数据</span></span><br><span class="line">    <span class="comment"># print(type(response_.text))  #string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(response_.content)  #打印响应的文本数据</span></span><br><span class="line">    <span class="comment"># print(type(response_.content))  #bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存数据</span></span><br><span class="line">    <span class="comment"># with open(&#x27;baidu01.html&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f: # 由于response_.text是字符串类型，所以直接写入即可</span></span><br><span class="line">    <span class="comment"># # 写入数据时遇到UnicodeEncodeError，加上encoding = &#x27;utf-8&#x27;即可</span></span><br><span class="line">    <span class="comment">#     f.write(response_.text) #保存的数据出现乱码，是因为从网络请求拿下来的数据都是字节类型，而响应对象的text属性是字符串类型，是因为text会自动识别编码格式，但不一定准确，解码错误就会出现乱码，所以一般直接使用响应对象的content属性，因为content属性是字节类型，可以自己指定编码格式，一般指定utf-8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;baidu02.html&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># wb二进制方法写入的话，不需要加encoding=&#x27;utf-8&#x27;</span></span><br><span class="line">        f.write(response_.content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pycharm直接打开本地html文件，会自动熏染，自动请求某些需要的部分</span></span><br><span class="line">    <span class="comment"># 通过终端打开本地html文件，不会自动渲染，需要手动请求，start html文件路径</span></span><br></pre></td></tr></table></figure><h3 id="响应对象response里的其它属性"><a href="#响应对象response里的其它属性" class="headerlink" title="响应对象response里的其它属性"></a>响应对象response里的其它属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应体</span></span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line">    <span class="built_in">print</span>(response.content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应状态码</span></span><br><span class="line">    <span class="built_in">print</span>(response.status_code)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应对应的请求头</span></span><br><span class="line">    <span class="built_in">print</span>(response.request.headers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应头</span></span><br><span class="line">    <span class="built_in">print</span>(response.headers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应对应请求的cookie</span></span><br><span class="line">    <span class="built_in">print</span>(response.request._cookies)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应的cookie</span></span><br><span class="line">    <span class="built_in">print</span>(response.cookies)</span><br></pre></td></tr></table></figure><p><img src="/img/crawler01/03.png"></p><h3 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h3><p>因为我们直接访问网站会被发现是爬虫，获取的数据有所缺少，为我们需要通过用户代理获取正确的数据。<br>对于服务端来说，是一个反爬点，对于我们来说，它是模拟正常正常用户的其中一个部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;baidu03.html&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(response.content)</span><br></pre></td></tr></table></figure><h2 id="URL传参"><a href="#URL传参" class="headerlink" title="URL传参"></a>URL传参</h2><h3 id="User-Agent池"><a href="#User-Agent池" class="headerlink" title="User-Agent池"></a>User-Agent池</h3><p>当我们需要短时间内连续多次访问一个服务器，服务器会记录我们的每一次访问，当服务器发现访问的是同一个User-Agent，会被判为我们是爬虫程序，可能会禁止我们的访问。<br>解决办法，使用User-Agent池，每次请求都从UA池中随机拿一个身份进行请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">ua_list = [<span class="string">&#x27;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent:Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent:Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent:Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent:Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent:Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent:Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11&#x27;</span></span><br><span class="line">           ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ua</span>():</span><br><span class="line">    header = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: random.choice(ua_list)&#125;</span><br><span class="line">    <span class="keyword">return</span> header</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(get_ua())</span><br><span class="line">    url_ = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line">    response = requests.get(url_, get_ua())</span><br><span class="line">    <span class="built_in">print</span>(response.request.headers)</span><br></pre></td></tr></table></figure><p>这里我还写了一个随机函数，会每次调用随机从ua池中选择一个ua，提升了代码的复用性。</p><h3 id="URL传参-1"><a href="#URL传参-1" class="headerlink" title="URL传参"></a>URL传参</h3><p>根据数据包的分析，发现每个图片都是单独的数据包，在接收到html的主框架后，浏览器发现有许因该放着图片的地方，放的是图片的url，此时浏览器就会拿着图片的url自动去发送网络请求，进行图片的填充，最终呈现完整的图片。<br>在url中，自？之后的都是参数，以键值对的方式存在，’&#x3D;’连接键与值，两个键值对之间用’&amp;’连接。而且只有部分键值对是必须的。<br>中文传参并不友好方便，会经过浏览器的解析在发送给服务器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote,unquote</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    input_wd = <span class="built_in">input</span>(<span class="string">&#x27;请输入要搜索的内容：&#x27;</span>)</span><br><span class="line">    wd = quote(input_wd)</span><br><span class="line">    <span class="comment"># 编码格式符合 URL编码解码格式</span></span><br><span class="line">    <span class="comment"># print(wd) # %E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;User-Agent:Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法一:</span></span><br><span class="line">    <span class="comment"># url_ = f&#x27;https://www.baidu.com/s?wd=&#123;wd&#125;&#x27;</span></span><br><span class="line">    <span class="comment"># response = requests.get(url_, headers=headers)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法二:</span></span><br><span class="line">    url_ = <span class="string">&#x27;https://www.baidu.com/s?&#x27;</span></span><br><span class="line">    params_ = &#123;</span><br><span class="line">       <span class="string">&#x27;wd&#x27;</span>: input_wd</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url_, headers=headers, params=params_)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;baidu.html&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(response.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一旦出现&#x27;百度安全验证&#x27;说明已经被反爬了。</span></span><br></pre></td></tr></table></figure><h2 id="贴吧案例"><a href="#贴吧案例" class="headerlink" title="贴吧案例"></a>贴吧案例</h2><p>使用面向对象完成贴吧翻页爬取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TieBa</span>:</span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.url_ = <span class="string">&#x27;https://tieba.baidu.com/f?&#x27;</span></span><br><span class="line">        self.headers_ = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求，得到响应对象</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_request</span>(<span class="params">self, params_</span>):</span><br><span class="line">        response_ = requests.get(self.url_, headers=self.headers_, params=params_)</span><br><span class="line">        str_data = response_.content.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> str_data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存数据            页数  内容       标题</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">self, page, str_data, data_</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;data_&#125;</span>_<span class="subst">&#123;page+<span class="number">1</span>&#125;</span>.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(str_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调度方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        data_ = <span class="built_in">input</span>(<span class="string">&#x27;请输入要搜索的内容：&#x27;</span>)</span><br><span class="line">        pages_ = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入要爬取的页数：&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环爬取多页</span></span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(pages_):</span><br><span class="line">            params_ = &#123;</span><br><span class="line">                <span class="string">&#x27;kw&#x27;</span>: data_,</span><br><span class="line">                <span class="string">&#x27;pn&#x27;</span>: page * <span class="number">50</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            str_data =  self.send_request(params_)</span><br><span class="line"></span><br><span class="line">            self.save_data(page, str_data, data_)</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tieba = TieBa()</span><br><span class="line">    tieba.run()</span><br></pre></td></tr></table></figure><h2 id="网易云案例"><a href="#网易云案例" class="headerlink" title="网易云案例"></a>网易云案例</h2><h3 id="非VIP的爬取"><a href="#非VIP的爬取" class="headerlink" title="非VIP的爬取"></a>非VIP的爬取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url_ = <span class="string">&#x27;https://m701.music.126.net/20240705095240/c4e8c9533fbc86da0341845a988fb336/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/44283587460/8809/cd66/6324/890ff412f637c908a7986b9fac0538b1.m4a&#x27;</span></span><br><span class="line"></span><br><span class="line">headers_ = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.1528.49&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url_, headers=headers_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在爬取图片、音频或者视频数据时，是将其字节数据进行保存</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;二十二.mp3&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(response.content)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，爬虫的基本知识就介绍完了，主要是对http协议、请求头、字符编码、requests库、URL传参。<br>尝试过贴吧案例和网易云案例，基本掌握了爬虫的基本操作。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-基础与学前准备</title>
      <link href="/2024/07/04/Crawler/"/>
      <url>/2024/07/04/Crawler/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫-基础与学前准备"><a href="#爬虫-基础与学前准备" class="headerlink" title="爬虫-基础与学前准备"></a>爬虫-基础与学前准备</h1><h2 id="爬虫基本介绍"><a href="#爬虫基本介绍" class="headerlink" title="爬虫基本介绍"></a>爬虫基本介绍</h2><p>网络爬虫（又被称为网页蜘蛛，网络机器人）就是模拟浏览器发送网络请求，接收请求响应，一种按照一定的规则，自动地抓取互联网信息的程序。</p><p>原则上,只要是浏览器(客户端)能做的事情，爬虫都能够做。</p><ul><li>爬虫：模拟客户端访问，抓取数据。</li><li>反爬：保护重要数据，阻止恶意网络攻击。</li><li>反反爬：针对反爬做的措施。</li></ul><h3 id="爬虫分类"><a href="#爬虫分类" class="headerlink" title="爬虫分类"></a>爬虫分类</h3><ul><li>通用爬虫：通过搜索引擎和大型Web服务提供商的爬虫</li><li>聚焦爬虫：针对特定网站的爬虫，定向的获取某方面数据的爬虫。</li></ul><p>聚焦爬虫又主要分为：累计式爬虫、增量式爬虫、Deep web爬虫（深层网络爬虫）。</p><h3 id="爬虫基本流程"><a href="#爬虫基本流程" class="headerlink" title="爬虫基本流程"></a>爬虫基本流程</h3><p><img src="/img/Crawler/01.jpg"></p><ul><li>向起始url发送请求，，并获取相应。</li><li>对响应进行提取。</li><li>如果提取数据，则1将数据进行保存。</li><li>如果提取url，则继续发送请求获取响应。</li></ul><h3 id="rorbots协议"><a href="#rorbots协议" class="headerlink" title="rorbots协议"></a>rorbots协议</h3><p>网站通过robots协议告诉搜索引擎哪些页面可以抓取。<br><img src="/img/Crawler/02.png"></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>初次接触爬虫部分的学习，习惯性创建一个虚拟环境负责这部分的学习。</p><h3 id="安装-mod"><a href="#安装-mod" class="headerlink" title="安装 mod"></a>安装 mod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i virtualenvwrapper-win</span><br></pre></td></tr></table></figure><h3 id="创建目录存放虚拟环境"><a href="#创建目录存放虚拟环境" class="headerlink" title="创建目录存放虚拟环境"></a>创建目录存放虚拟环境</h3><p>略</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>以 WORKON_HOME 为名，值选择一个目录，以后所有使用virtualenvwrapper管理的虚拟环境都会在这个目录中。</p><p><img src="/img/Crawler/03.png"></p><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv path(python的路径，如：C:\environment\Python3.10\python.exe) 虚拟环境名</span><br></pre></td></tr></table></figure><h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmvirtualenv 虚拟环境名</span><br></pre></td></tr></table></figure><h3 id="列出虚拟环境"><a href="#列出虚拟环境" class="headerlink" title="列出虚拟环境"></a>列出虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsvirtualenv</span><br><span class="line">或者</span><br><span class="line">workon</span><br></pre></td></tr></table></figure><p><img src="/img/Crawler/04.png"></p><h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workon 虚拟环境名</span><br></pre></td></tr></table></figure><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><p>这里我学习使用的是谷歌浏览器和pycharm。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们已经对爬虫有所了解，学习了如何使用python搭建虚拟环境，并且做好学习爬虫的准备事项了。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sass</title>
      <link href="/2024/05/14/sass/"/>
      <url>/2024/05/14/sass/</url>
      
        <content type="html"><![CDATA[<h1 id="Sass-基础"><a href="#Sass-基础" class="headerlink" title="Sass 基础"></a>Sass 基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Sass 是一个 CSS 预处理器。<br>Sass 扩展了 CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。<br>Sass 生成良好格式化的 CSS 代码，易于组织和维护。<br>Sass 完全兼容所有版本的 CSS。<br>Sass 文件后缀为 .scss。</p><p>简单来说 Sass 可以让我们以一种更灵活更有效的方式去写 css 的样式。</p><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass -g</span><br></pre></td></tr></table></figure><p>因为 Ruby-sass 和 node-sass 已经是历史了，所以这里我们安装的是 dart-sass。<br>下载之后可以用下载命令检查 sass 的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass --version</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>浏览器并不支持 Sass 代码。因此，你需要使用一个 Sass 预处理器将 Sass 代码转换为 CSS 代码。<br>我们可以编辑一个 text.scss 文件，内容如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义变量与值 */</span></span><br><span class="line"><span class="variable">$bgcolor</span>: lightblue;</span><br><span class="line"><span class="variable">$textcolor</span>: darkblue;</span><br><span class="line"><span class="variable">$fontsize</span>: <span class="number">18px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用变量 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$bgcolor</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$textcolor</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$fontsize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们已经看到了 scss 中的定义变量，是以 $variablename: value; 的形式进行赋值的。<br>接着我们在文件所在文件夹打开终端，运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass text.scss text.css</span><br></pre></td></tr></table></figure><p>这条命令会告诉 Sass 编译器将 text.scss 文件编译成 text.css 文件，同时生成一个源映射（source map）文件 text.css.map，这个源映射文件用于调试，允许开发者追踪 CSS 规则回对应的 .scss 文件。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量属性"><a href="#变量属性" class="headerlink" title="变量属性"></a>变量属性</h4><p>前面我们已经了解过如何定义变量了，接下来我们了解一下变量的其它内容。<br>Sass 变量可以存储以下信息：</p><ul><li>字符串</li><li>数字</li><li>颜色值</li><li>布尔值</li><li>列表</li><li>null 值</li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域方面，Sass 变量的作用域只能在当前的层级上有效果。<br>当然 Sass 中我们可以使用 !global 关键词来设置变量是全局的。</p><p>注意：所有的全局变量我们一般定义在同一个文件，如：_globals.scss，然后我们使用 @import “globals”;  来包含该文件。</p><h3 id="Sass-嵌套规则与属性"><a href="#Sass-嵌套规则与属性" class="headerlink" title="Sass 嵌套规则与属性"></a>Sass 嵌套规则与属性</h3><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>Sass 嵌套 CSS 选择器类似于 HTML 的嵌套规则。<br>如下我们嵌套一个导航栏的样式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nav &#123;</span><br><span class="line">  ul &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style: none;</span><br><span class="line">  &#125;</span><br><span class="line">  li &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">  a &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    padding: 6px 12px;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>很多 CSS 属性都有同样的前缀，例如：font-family, font-size 和 font-weight ， text-align, text-transform 和 text-overflow。<br>在 Sass 中，我们可以使用嵌套属性来编写它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">font: &#123;</span><br><span class="line">  family: Helvetica, sans-serif;</span><br><span class="line">  size: 18px;</span><br><span class="line">  weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">text: &#123;</span><br><span class="line">  align: center;</span><br><span class="line">  transform: lowercase;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sass-import"><a href="#Sass-import" class="headerlink" title="Sass @import"></a>Sass @import</h3><h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p>类似 CSS，Sass 支持 @import 指令。<br>@import 指令可以让我们导入其他文件等内容。<br>CSS @import 指令在每次调用时，都会创建一个额外的 HTTP 请求。但，Sass @import 指令将文件包含在 CSS 中，不需要额外的 HTTP 请求。<br>Sass @import 指令语法如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> filename;</span><br></pre></td></tr></table></figure><p>注：包含文件时不需要指定文件后缀，Sass 会自动添加 .scss 后缀。</p><h5 id="Sass-Partials"><a href="#Sass-Partials" class="headerlink" title="Sass Partials"></a>Sass Partials</h5><p>除此之外，部分文件（Sass Partials）这个特性可以允许我们将我们的样式分成多个文件，使得我们的样式表更加模块化和组织化。部分文件通常包含不会直接生成 CSS 文件的样式代码，而是被其他 Sass 文件导入使用。<br>部分文件通过在文件名前添加一个下划线（_）来表示，例如 _variables.scss、_mixins.scss 等。Sass 编译器在编译时会忽略以下划线开头的文件，这意味着它们不会被编译成对应的 CSS 文件。相反，它们设计为被其他 Sass 文件导入。</p><h3 id="Sass-mixin-与-include"><a href="#Sass-mixin-与-include" class="headerlink" title="Sass @mixin 与 @include"></a>Sass @mixin 与 @include</h3><blockquote><p>@mixin 指令允许我们定义一个可以在整个样式表中重复使用的样式。<br>@include 指令可以将混入（mixin）引入到文档中。</p></blockquote><h4 id="定义混入"><a href="#定义混入" class="headerlink" title="定义混入"></a>定义混入</h4><p>我们通过 @mixin name {} 来创建一个名为 “name” 的混入。</p><p>注意：Sass 的连接符号 - 与下划线符号 _ 是相同的，也就是 @mixin important-text { } 与 @mixin important_text { } 是一样的混入。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> important-text &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用混入"><a href="#使用混入" class="headerlink" title="使用混入"></a>使用混入</h4><p>@include 指令可用于包含一混入：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selector &#123;</span><br><span class="line">  <span class="keyword">@include</span> mixin-name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，混入中也可以包含混入。</p><h4 id="向混入传递变量"><a href="#向混入传递变量" class="headerlink" title="向混入传递变量"></a>向混入传递变量</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 混入接收两个参数 */</span></span><br><span class="line"><span class="keyword">@mixin</span> bordered(<span class="variable">$color</span>, <span class="variable">$width</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$width</span> solid <span class="variable">$color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.myArticle</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> bordered(blue, <span class="number">1px</span>);  <span class="comment">// 调用混入，并传递两个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.myNotes</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> bordered(red, <span class="number">2px</span>); <span class="comment">// 调用混入，并传递两个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混入和函数可以接受多个参数，用 … 来设置可变参数。</p><h3 id="Sass-extend-与-继承"><a href="#Sass-extend-与-继承" class="headerlink" title="Sass @extend 与 继承"></a>Sass @extend 与 继承</h3><p>@extend 指令告诉 Sass 一个选择器的样式从另一选择器继承。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button-basic</span>  &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button-report</span>  &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .button-basic;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button-submit</span>  &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .button-basic;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sass-函数"><a href="#Sass-函数" class="headerlink" title="Sass 函数"></a>Sass 函数</h3><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>Sass 定义了各种类型的函数，这些函数我们可以通过 CSS 语句直接调用。</p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@function</span> name(<span class="variable">$value</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 初探</title>
      <link href="/2024/05/11/webpack/"/>
      <url>/2024/05/11/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="初始-Webpack"><a href="#初始-Webpack" class="headerlink" title="初始 Webpack"></a>初始 Webpack</h1><p>Webpack  是一个前端资源加载&#x2F;打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p><p><img src="/img/webpack/webpack.png" alt="img"></p><h2 id="安装-Webpack"><a href="#安装-Webpack" class="headerlink" title="安装 Webpack"></a>安装 Webpack</h2><p>注：本地环境需要支持 <a href="https://nodejs.org/en">node.js</a><br>使用npm安装webpack：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -g</span><br></pre></td></tr></table></figure><ul><li>webpack：一个模块打包工具</li><li>webpack-cli：是它的命令行工具，允许你从命令行运行 webpack。</li></ul><h2 id="尝试使用-Webpack"><a href="#尝试使用-Webpack" class="headerlink" title="尝试使用 Webpack"></a>尝试使用 Webpack</h2><p>创建一个项目，并进入项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir project </span><br><span class="line">cd project</span><br></pre></td></tr></table></figure><p>初始化项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>可以直接在项目的根目录下打开终端执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>这些包会被安装在当前项目的 node_modules 目录下，并且它们的记录会被添加到 package.json 文件的 devDependencies 部分。这样做通常是因为这些包只在开发阶段需要，比如进行项目构建或测试，而不需要在生产环境中。</p><p>使用 vscod 打开当前目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code ./</span><br></pre></td></tr></table></figure><p>创建文件 &#x2F;src&#x2F;data.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getBlogPosts</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;POST 1&quot;</span>, <span class="string">&quot;POST 2&quot;</span>, <span class="string">&quot;POST 3&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建文件 &#x2F;src&#x2F;index.js ，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getBlogPosts &#125; from &#x27;./data&#x27;</span><br><span class="line"></span><br><span class="line">console.log(getBlogPosts())</span><br></pre></td></tr></table></figure><p>创建文件 &#x2F;index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Webpack<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./src/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>进行打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>项目中会生成 &#x2F;dist&#x2F;main.js 文件，这样就完成了一个简单的打包。</p><p>但在打包工程中会有如下警告，这是因为webpack官方在4中新增了： mode 配置选项，告知 webpack 使用相应模式的内置优化。可配置的值是production、development 和 none，默认为production。<br><img src="/img/webpack/01.png" alt="warning"></p><h2 id="配置-Webpck"><a href="#配置-Webpck" class="headerlink" title="配置 Webpck"></a>配置 Webpck</h2><p>创建 &#x2F;webpack.config.js 文件，其内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;test.js&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname + <span class="string">&quot;/dist&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mode: “development”：设置构建模式为开发模式。Webpack 还支持 production 模式，用于生产环境的构建。</li><li>entry: “.&#x2F;src&#x2F;index.js”：指定入口文件为 src 目录下的 index.js 文件。Webpack 会从这个文件开始，递归地构建一个依赖图，包含所有需要的模块。</li><li>output: { … }：配置输出选项。<ul><li>filename: “test.js”：设置输出文件的名称为 test.js。</li><li>path: path.resolve(__dirname + “&#x2F;dist”)：设置输出文件存放的路径为当前目录下的 dist 目录。__dirname 是 Node.js 中的一个全局变量，表示当前文件所在的目录。</li></ul></li></ul><p>再次打包后，文件就打包好的文件位置就是 &#x2F;dist&#x2F;test.js<br>当我们尝试编写 css 文件，并进行打包时，会有以下报错：<br><img src="/img/webpack/02.jpg" alt="image-20240511100739299"></p><p>这个报错是在提醒我们可能需要安装 style-loader css-loader 两个 loader。<br>在项目中添加这两个 loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add --save-dev stystyle-loader css-loader</span><br></pre></td></tr></table></figure><p>在 &#x2F;webpack.config.js 中进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">            rules: [</span><br><span class="line">                &#123;</span><br><span class="line">                    test: /\.css$/i,</span><br><span class="line">                    use: [&quot;style-loader&quot;,&quot;css-loader&quot;]</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    test: /\.(png|jpe?g|gif|svg)$/i,</span><br><span class="line">                    type: &quot;asset/resource&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>test：用来匹配文件</p></li><li><p>use：所匹配的文件所用到的loader</p></li><li><p>type：所用的为 webpack 内置的 loader</p></li></ul><h2 id="在webpack中使用插件"><a href="#在webpack中使用插件" class="headerlink" title="在webpack中使用插件"></a>在webpack中使用插件</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>让打包时自动生成 html 文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>配置 webpack.config.js </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;Webpack Test&quot;</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行打包程序后，&#x2F;dist&#x2F;index.html 就为自动生成的页面</p><h3 id="打包符合-ES6-标准的-JS-文件"><a href="#打包符合-ES6-标准的-JS-文件" class="headerlink" title="打包符合 ES6 标准的 JS 文件"></a>打包符合 ES6 标准的 JS 文件</h3><p>在开发前端项目时，我们时常使用到新版本的 JS 特性，但要兼容低版本的浏览器，可以用 babel 这个工具转译我们的 JS 代码。<br>添加 webpack 中的 loader：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add --save-dev babel-loader @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure><p>webpack.config.js 中的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">devtool</span>: <span class="string">&quot;inline-source-map&quot;</span>,</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>:[</span><br><span class="line">&#123;<span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次打包文件后，js 文件按照 ES6 的标准打包。</p><h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p>压缩 JS 文件的体积，需要用到 terser-webpack-plugin 的插件，首先先安装一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add terser-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>并在 webpack.config.js 中配置一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minimizer</span>: [<span class="keyword">new</span> <span class="title class_">TerserPlugin</span>()],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后发现 JS 文件的空格都去掉了，并且变量名都是简化的形式，文件的最后是图片被压缩成 base64。</p><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p>目前为止，我们每次改动都需要重新打包，而 wabpack-dev-server 这个工具可以帮助我们省去这个步骤。<br>安装 wabpack-dev-server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><p>配置 webpack.config.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">static</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便我们的打包，可以在 package.json 中进行配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack serve --open&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这是，在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>就可以打包并打开浏览器。</p><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>虽然打包的文件名是一样的，但是浏览器会对每次打开的页面进行缓存，如果不更新文件名，浏览器可能不更新，为了避免浏览器缓存，我们会给文件名加上一串随机的字符，每次更新之后都改为新的字符。webpack 也提供在打包后生成一段新的字符。<br>在 webpack.json.js 中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;[name].[contenthash].js&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname + <span class="string">&quot;/dist&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h3><p>有时候 JS 所在文件的路径嵌套比较深，要引入其他目录下的 JS 比较麻烦，webpack可以让我们指定一个路径别名。<br>在 webpack.json.js 中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="attr">utils</span>: path.<span class="title function_">resolve</span>(__dirname + <span class="string">&quot;/src/utils/&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以用路径 “utils&#x2F;“ 表示 路径 “&#x2F;src&#x2F;utils&#x2F;“。</p><h3 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h3><p>在打包后我们可能要对体积大的文件进行进一步优化，webpack 中有一个可视化的打包分析工具 webpack-bundle-analyzer。首先进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure><p>并在 webpack.config.js 中进行配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">BundleAnalyzerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>.<span class="title class_">BundleAnalyzerPlugin</span>()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行打包程序后，可在 <a href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a> 进行访问。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
